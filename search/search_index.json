{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ethereum KMS Signer \u00b6 Sign ETH transactions with keys stored in AWS KMS Free software: MIT Documentation: https://meetmangukiya.github.io/ethereum-kms-signer Features \u00b6 Sign Transactions Video Demo \u00b6 Why? \u00b6 In the crypto world, all the assets, tokens, crypto you might own is protected by the secrecy of the private key. This leads to a single point of failure in cases of leaking of private keys or losing keys because of lack of backup or any number of reasons. It becomes even harder when you want to share these keys as an organization among many individuals. Using something like AWS KMS can help with that and can provide full benefits of all the security features it provides. Sigantures can be created without the key ever leaving the AWS's infrastructure and could be effectively shared among individuals. This library provides a simple and an easy-to-use API for using AWS KMS to sign ethereum transactions and an easy integration with web3.py making it practical for using KMS to manage your private keys. Quickstart \u00b6 Get ethereum address from KMS key \u00b6 1 2 3 from ethereum_kms_signer import get_eth_address address = get_eth_address ( 'THE-AWS-KMS-ID' ) print ( address ) Sign a transaction object with KMS key \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from ethereum_kms_signer import sign_transaction dai_txn = dai . functions . transfer ( web3 . toChecksumAddress ( to_address . lower ()), amount ) . buildTransaction ( { \"nonce\" : nonce , } ) # Signing the transaction with KMS key signed_tx = sign_transaction ( dai_txn , key_id ) # send transaction tx_hash = web3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) Provisioning AWS KMS key with terraform \u00b6 An ECC_SECG_P256K1 key can be provisioned using terraform by using the following configuration along with the aws provider. More details can be found on provider docs 1 2 3 4 5 6 7 8 9 10 resource \"aws_kms_key\" \"my_very_secret_eth_account\" { description = \"ETH account #1\" key_usage = \"SIGN_VERIFY\" customer_master_key_spec = \"ECC_SECG_P256K1\" } resource \"aws_kms_alias\" \"my_very_secret_eth_account\" { name = \"eth-account-1\" target_key_id = aws_kms_key.my_very_secret_eth_account.id } Examples \u00b6 Few examples can be found here . Credits \u00b6 This package was created with Cookiecutter and the zillionare/cookiecutter-pypackage project template. This article has served as a good resource for implementing the functionality","title":"home"},{"location":"#ethereum-kms-signer","text":"Sign ETH transactions with keys stored in AWS KMS Free software: MIT Documentation: https://meetmangukiya.github.io/ethereum-kms-signer","title":"Ethereum KMS Signer"},{"location":"#features","text":"Sign Transactions","title":"Features"},{"location":"#video-demo","text":"","title":"Video Demo"},{"location":"#why","text":"In the crypto world, all the assets, tokens, crypto you might own is protected by the secrecy of the private key. This leads to a single point of failure in cases of leaking of private keys or losing keys because of lack of backup or any number of reasons. It becomes even harder when you want to share these keys as an organization among many individuals. Using something like AWS KMS can help with that and can provide full benefits of all the security features it provides. Sigantures can be created without the key ever leaving the AWS's infrastructure and could be effectively shared among individuals. This library provides a simple and an easy-to-use API for using AWS KMS to sign ethereum transactions and an easy integration with web3.py making it practical for using KMS to manage your private keys.","title":"Why?"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#get-ethereum-address-from-kms-key","text":"1 2 3 from ethereum_kms_signer import get_eth_address address = get_eth_address ( 'THE-AWS-KMS-ID' ) print ( address )","title":"Get ethereum address from KMS key"},{"location":"#sign-a-transaction-object-with-kms-key","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from ethereum_kms_signer import sign_transaction dai_txn = dai . functions . transfer ( web3 . toChecksumAddress ( to_address . lower ()), amount ) . buildTransaction ( { \"nonce\" : nonce , } ) # Signing the transaction with KMS key signed_tx = sign_transaction ( dai_txn , key_id ) # send transaction tx_hash = web3 . eth . sendRawTransaction ( signed_tx . rawTransaction )","title":"Sign a transaction object with KMS key"},{"location":"#provisioning-aws-kms-key-with-terraform","text":"An ECC_SECG_P256K1 key can be provisioned using terraform by using the following configuration along with the aws provider. More details can be found on provider docs 1 2 3 4 5 6 7 8 9 10 resource \"aws_kms_key\" \"my_very_secret_eth_account\" { description = \"ETH account #1\" key_usage = \"SIGN_VERIFY\" customer_master_key_spec = \"ECC_SECG_P256K1\" } resource \"aws_kms_alias\" \"my_very_secret_eth_account\" { name = \"eth-account-1\" target_key_id = aws_kms_key.my_very_secret_eth_account.id }","title":"Provisioning AWS KMS key with terraform"},{"location":"#examples","text":"Few examples can be found here .","title":"Examples"},{"location":"#credits","text":"This package was created with Cookiecutter and the zillionare/cookiecutter-pypackage project template. This article has served as a good resource for implementing the functionality","title":"Credits"},{"location":"api/","text":"\u00b6 Top-level package for Ethereum KMS Signer. cli \u00b6 Console script for ethereum_kms_signer. kms \u00b6 BasicKmsAccount \u00b6 Kinda compatible eth_keys.PrivateKey class Signature \u00b6 Kinda compatible Signature class SignedTransaction \u00b6 Kinda compatible SignedTransaction class __getnewargs__ ( self ) special \u00b6 Return self as a plain tuple. Used by copy and pickle. Source code in ethereum_kms_signer/kms.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , rawTransaction , hash , r , s , v ) special staticmethod \u00b6 Create new instance of SignedTransaction(rawTransaction, hash, r, s, v) __repr__ ( self ) special \u00b6 Return a nicely formatted representation string Source code in ethereum_kms_signer/kms.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self get_eth_address ( key_id , kms_client = None ) \u00b6 Calculate ethereum address for given AWS KMS key. Source code in ethereum_kms_signer/kms.py def get_eth_address ( key_id : str , kms_client : KMSClient = None ) -> str : \"\"\"Calculate ethereum address for given AWS KMS key.\"\"\" if kms_client is None : kms_client = boto3 . client ( \"kms\" ) pubkey = kms_client . get_public_key ( KeyId = key_id )[ \"PublicKey\" ] return der_encoded_public_key_to_eth_address ( pubkey ) sign_transaction ( tx_obj , key_id , kms_client = None ) \u00b6 Sign a transaction object with given AWS KMS key. Source code in ethereum_kms_signer/kms.py def sign_transaction ( tx_obj : dict , key_id : str , kms_client : KMSClient = None ) -> SignedTransaction : \"\"\"Sign a transaction object with given AWS KMS key.\"\"\" if kms_client is None : kms_client = boto3 . client ( \"kms\" ) kms_pub_key_bytes = kms_client . get_public_key ( KeyId = key_id )[ \"PublicKey\" ] address = der_encoded_public_key_to_eth_address ( kms_pub_key_bytes ) kms_account = BasicKmsAccount ( key_id , address , kms_client ) return _sign_transaction ( tx_obj , address , kms_account ) spki \u00b6 der_encoded_public_key_to_eth_address ( pubkey ) \u00b6 Given a KMS Public Key, calculate the ethereum address. Source code in ethereum_kms_signer/spki.py def der_encoded_public_key_to_eth_address ( pubkey : bytes ) -> str : \"\"\" Given a KMS Public Key, calculate the ethereum address. \"\"\" received_record , _ = der_decode ( pubkey , asn1Spec = SPKIRecord ()) return public_key_int_to_eth_address ( int ( received_record [ \"subjectPublicKey\" ] . asBinary (), 2 ) ) get_sig_r_s ( signature ) \u00b6 Given a KMS signature, calculate r and s. Source code in ethereum_kms_signer/spki.py def get_sig_r_s ( signature : bytes ) -> Tuple [ int , int ]: \"\"\" Given a KMS signature, calculate r and s. \"\"\" received_record , _ = der_decode ( signature , asn1Spec = ECDSASignatureRecord ()) r = int ( received_record [ \"r\" ] . prettyPrint ()) s = int ( received_record [ \"s\" ] . prettyPrint ()) max_value_on_curve = ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 ) if 2 * s >= max_value_on_curve : # s is on wrong side of curve, flip it s = max_value_on_curve - s return r , s get_sig_r_s_v ( msg_hash , signature , address ) \u00b6 Given a message hash, a KMS signature and an ethereum address calculate r, s, and v. Source code in ethereum_kms_signer/spki.py def get_sig_r_s_v ( msg_hash : bytes , signature : bytes , address : str ) -> Tuple [ int , int , int ]: \"\"\" Given a message hash, a KMS signature and an ethereum address calculate r, s, and v. \"\"\" r , s = get_sig_r_s ( signature ) v = get_sig_v ( msg_hash , r , s , address ) return r , s , v get_sig_v ( msg_hash , r , s , expected_address ) \u00b6 Given a message hash, r, s and an ethereum address, recover the recovery parameter v. Source code in ethereum_kms_signer/spki.py def get_sig_v ( msg_hash : bytes , r : int , s : int , expected_address : str ) -> int : \"\"\" Given a message hash, r, s and an ethereum address, recover the recovery parameter v. \"\"\" acc = Account () recovered = acc . _recover_hash ( msg_hash , vrs = ( 27 , r , s )) recovered2 = acc . _recover_hash ( msg_hash , vrs = ( 28 , r , s )) expected_checksum_address = to_checksum_address ( expected_address ) if recovered == expected_checksum_address : return 0 elif recovered2 == expected_checksum_address : return 1 raise ValueError ( \"Invalid Signature, cannot compute v, addresses do not match!\" ) public_key_int_to_eth_address ( pubkey ) \u00b6 Given an integer public key, calculate the ethereum address. Source code in ethereum_kms_signer/spki.py def public_key_int_to_eth_address ( pubkey : int ) -> str : \"\"\" Given an integer public key, calculate the ethereum address. \"\"\" hex_string = hex ( pubkey ) . replace ( \"0x\" , \"\" ) padded_hex_string = hex_string . replace ( \"0x\" , \"\" ) . zfill ( 130 )[ 2 :] k = keccak . new ( digest_bits = 256 ) k . update ( bytes . fromhex ( padded_hex_string )) return to_checksum_address ( bytes . fromhex ( k . hexdigest ())[ - 20 :] . hex ())","title":"modules"},{"location":"api/#ethereum_kms_signer","text":"Top-level package for Ethereum KMS Signer.","title":"ethereum_kms_signer"},{"location":"api/#ethereum_kms_signer.cli","text":"Console script for ethereum_kms_signer.","title":"cli"},{"location":"api/#ethereum_kms_signer.kms","text":"","title":"kms"},{"location":"api/#ethereum_kms_signer.kms.BasicKmsAccount","text":"Kinda compatible eth_keys.PrivateKey class","title":"BasicKmsAccount"},{"location":"api/#ethereum_kms_signer.kms.Signature","text":"Kinda compatible Signature class","title":"Signature"},{"location":"api/#ethereum_kms_signer.kms.SignedTransaction","text":"Kinda compatible SignedTransaction class","title":"SignedTransaction"},{"location":"api/#ethereum_kms_signer.kms.SignedTransaction.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in ethereum_kms_signer/kms.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"api/#ethereum_kms_signer.kms.SignedTransaction.__new__","text":"Create new instance of SignedTransaction(rawTransaction, hash, r, s, v)","title":"__new__()"},{"location":"api/#ethereum_kms_signer.kms.SignedTransaction.__repr__","text":"Return a nicely formatted representation string Source code in ethereum_kms_signer/kms.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"api/#ethereum_kms_signer.kms.get_eth_address","text":"Calculate ethereum address for given AWS KMS key. Source code in ethereum_kms_signer/kms.py def get_eth_address ( key_id : str , kms_client : KMSClient = None ) -> str : \"\"\"Calculate ethereum address for given AWS KMS key.\"\"\" if kms_client is None : kms_client = boto3 . client ( \"kms\" ) pubkey = kms_client . get_public_key ( KeyId = key_id )[ \"PublicKey\" ] return der_encoded_public_key_to_eth_address ( pubkey )","title":"get_eth_address()"},{"location":"api/#ethereum_kms_signer.kms.sign_transaction","text":"Sign a transaction object with given AWS KMS key. Source code in ethereum_kms_signer/kms.py def sign_transaction ( tx_obj : dict , key_id : str , kms_client : KMSClient = None ) -> SignedTransaction : \"\"\"Sign a transaction object with given AWS KMS key.\"\"\" if kms_client is None : kms_client = boto3 . client ( \"kms\" ) kms_pub_key_bytes = kms_client . get_public_key ( KeyId = key_id )[ \"PublicKey\" ] address = der_encoded_public_key_to_eth_address ( kms_pub_key_bytes ) kms_account = BasicKmsAccount ( key_id , address , kms_client ) return _sign_transaction ( tx_obj , address , kms_account )","title":"sign_transaction()"},{"location":"api/#ethereum_kms_signer.spki","text":"","title":"spki"},{"location":"api/#ethereum_kms_signer.spki.der_encoded_public_key_to_eth_address","text":"Given a KMS Public Key, calculate the ethereum address. Source code in ethereum_kms_signer/spki.py def der_encoded_public_key_to_eth_address ( pubkey : bytes ) -> str : \"\"\" Given a KMS Public Key, calculate the ethereum address. \"\"\" received_record , _ = der_decode ( pubkey , asn1Spec = SPKIRecord ()) return public_key_int_to_eth_address ( int ( received_record [ \"subjectPublicKey\" ] . asBinary (), 2 ) )","title":"der_encoded_public_key_to_eth_address()"},{"location":"api/#ethereum_kms_signer.spki.get_sig_r_s","text":"Given a KMS signature, calculate r and s. Source code in ethereum_kms_signer/spki.py def get_sig_r_s ( signature : bytes ) -> Tuple [ int , int ]: \"\"\" Given a KMS signature, calculate r and s. \"\"\" received_record , _ = der_decode ( signature , asn1Spec = ECDSASignatureRecord ()) r = int ( received_record [ \"r\" ] . prettyPrint ()) s = int ( received_record [ \"s\" ] . prettyPrint ()) max_value_on_curve = ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 ) if 2 * s >= max_value_on_curve : # s is on wrong side of curve, flip it s = max_value_on_curve - s return r , s","title":"get_sig_r_s()"},{"location":"api/#ethereum_kms_signer.spki.get_sig_r_s_v","text":"Given a message hash, a KMS signature and an ethereum address calculate r, s, and v. Source code in ethereum_kms_signer/spki.py def get_sig_r_s_v ( msg_hash : bytes , signature : bytes , address : str ) -> Tuple [ int , int , int ]: \"\"\" Given a message hash, a KMS signature and an ethereum address calculate r, s, and v. \"\"\" r , s = get_sig_r_s ( signature ) v = get_sig_v ( msg_hash , r , s , address ) return r , s , v","title":"get_sig_r_s_v()"},{"location":"api/#ethereum_kms_signer.spki.get_sig_v","text":"Given a message hash, r, s and an ethereum address, recover the recovery parameter v. Source code in ethereum_kms_signer/spki.py def get_sig_v ( msg_hash : bytes , r : int , s : int , expected_address : str ) -> int : \"\"\" Given a message hash, r, s and an ethereum address, recover the recovery parameter v. \"\"\" acc = Account () recovered = acc . _recover_hash ( msg_hash , vrs = ( 27 , r , s )) recovered2 = acc . _recover_hash ( msg_hash , vrs = ( 28 , r , s )) expected_checksum_address = to_checksum_address ( expected_address ) if recovered == expected_checksum_address : return 0 elif recovered2 == expected_checksum_address : return 1 raise ValueError ( \"Invalid Signature, cannot compute v, addresses do not match!\" )","title":"get_sig_v()"},{"location":"api/#ethereum_kms_signer.spki.public_key_int_to_eth_address","text":"Given an integer public key, calculate the ethereum address. Source code in ethereum_kms_signer/spki.py def public_key_int_to_eth_address ( pubkey : int ) -> str : \"\"\" Given an integer public key, calculate the ethereum address. \"\"\" hex_string = hex ( pubkey ) . replace ( \"0x\" , \"\" ) padded_hex_string = hex_string . replace ( \"0x\" , \"\" ) . zfill ( 130 )[ 2 :] k = keccak . new ( digest_bits = 256 ) k . update ( bytes . fromhex ( padded_hex_string )) return to_checksum_address ( bytes . fromhex ( k . hexdigest ())[ - 20 :] . hex ())","title":"public_key_int_to_eth_address()"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Meet Mangukiya meet@flamy.dev Contributors \u00b6 None yet. Why not be the first?","title":"authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Meet Mangukiya meet@flamy.dev","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/meetmangukiya/ethereum_kms_signer/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Ethereum KMS Signer could always use more documentation, whether as part of the official Ethereum KMS Signer docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/meetmangukiya/ethereum_kms_signer/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up ethereum_kms_signer for local development. Fork the ethereum_kms_signer repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/ethereum_kms_signer.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/meetmangukiya/ethereum_kms_signer/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_ethereum_kms_signer ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/meetmangukiya/ethereum_kms_signer/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"Ethereum KMS Signer could always use more documentation, whether as part of the official Ethereum KMS Signer docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/meetmangukiya/ethereum_kms_signer/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up ethereum_kms_signer for local development. Fork the ethereum_kms_signer repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/ethereum_kms_signer.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/meetmangukiya/ethereum_kms_signer/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_ethereum_kms_signer ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.6 (2021-11-11) \u00b6 fix import errors from missing boto3 kms stubs 0.1.5 (2021-10-30) \u00b6 removed unused packages marked relevant packages as dev-dependencies 0.1.4 (2021-09-29) \u00b6 Type hints for everything! 0.1.3 (2021-09-29) \u00b6 Allow overriding kms_client. 0.1.2 (2021-09-29) \u00b6 Documentation improvement. 0.1.1 (2021-09-29) \u00b6 Documentation improvement. 0.1.0 (2021-09-09) \u00b6 First release on PyPI.","title":"history"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#016-2021-11-11","text":"fix import errors from missing boto3 kms stubs","title":"0.1.6 (2021-11-11)"},{"location":"history/#015-2021-10-30","text":"removed unused packages marked relevant packages as dev-dependencies","title":"0.1.5 (2021-10-30)"},{"location":"history/#014-2021-09-29","text":"Type hints for everything!","title":"0.1.4 (2021-09-29)"},{"location":"history/#013-2021-09-29","text":"Allow overriding kms_client.","title":"0.1.3 (2021-09-29)"},{"location":"history/#012-2021-09-29","text":"Documentation improvement.","title":"0.1.2 (2021-09-29)"},{"location":"history/#011-2021-09-29","text":"Documentation improvement.","title":"0.1.1 (2021-09-29)"},{"location":"history/#010-2021-09-09","text":"First release on PyPI.","title":"0.1.0 (2021-09-09)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install Ethereum KMS Signer, run this command in your terminal: 1 $ pip install ethereum_kms_signer This is the preferred method to install Ethereum KMS Signer, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Ethereum KMS Signer can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/meetmangukiya/ethereum_kms_signer Or download the tarball : 1 $ curl -OJL https://github.com/meetmangukiya/ethereum_kms_signer/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install Ethereum KMS Signer, run this command in your terminal: 1 $ pip install ethereum_kms_signer This is the preferred method to install Ethereum KMS Signer, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for Ethereum KMS Signer can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/meetmangukiya/ethereum_kms_signer Or download the tarball : 1 $ curl -OJL https://github.com/meetmangukiya/ethereum_kms_signer/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use Ethereum KMS Signer in a project 1 import ethereum_kms_signer Authentication \u00b6 The library uses boto3 , by default you do not need to provide or do anything if: 1. You have config stored in ~/.aws 2. Have set the relevant environment variables More info here . You can provide the kwarg kms_client to which an authenticated kms client instance can be passed. For instance, if you want to provide keys via local variables you can do: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import boto3 from ethereum_kms_signer import sign_transaction , get_eth_address ACCESS_KEY = 'access_key' SECRET_KEY = 'secret_key' SESSION_TOKEN = 'session_token' kms_client = boto3 . client ( 'kms' , aws_access_key_id = ACCESS_KEY , aws_secret_access_key = SECRET_KEY , aws_session_token = SESSION_TOKEN ) key_id = 'key_id' address = get_eth_address ( key_id , kms_client ) signed_tx = sign_transaction ( tx_obj , key_id , kms_client ) Get ethereum address from KMS key \u00b6 1 2 3 from ethereum_kms_signer import get_eth_address address = get_eth_address ( 'THE-AWS-KMS-ID' ) print ( address ) Sign a transaction object with KMS key \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from ethereum_kms_signer import sign_transaction dai_txn = dai . functions . transfer ( web3 . toChecksumAddress ( to_address . lower ()), amount ) . buildTransaction ( { \"nonce\" : nonce , } ) # Signing the transaction with KMS key signed_tx = sign_transaction ( dai_txn , key_id ) # send transaction tx_hash = web3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) Provisioning AWS KMS key with terraform \u00b6 An ECC_SECG_P256K1 key can be provisioned using terraform by using the following configuration along with the aws provider. More details can be found on provider docs 1 2 3 4 5 6 7 8 9 10 resource \"aws_kms_key\" \"my_very_secret_eth_account\" { description = \"ETH account #1\" key_usage = \"SIGN_VERIFY\" customer_master_key_spec = \"ECC_SECG_P256K1\" } resource \"aws_kms_alias\" \"my_very_secret_eth_account\" { name = \"eth-account-1\" target_key_id = aws_kms_key.my_very_secret_eth_account.id }","title":"usage"},{"location":"usage/#usage","text":"To use Ethereum KMS Signer in a project 1 import ethereum_kms_signer","title":"Usage"},{"location":"usage/#authentication","text":"The library uses boto3 , by default you do not need to provide or do anything if: 1. You have config stored in ~/.aws 2. Have set the relevant environment variables More info here . You can provide the kwarg kms_client to which an authenticated kms client instance can be passed. For instance, if you want to provide keys via local variables you can do: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import boto3 from ethereum_kms_signer import sign_transaction , get_eth_address ACCESS_KEY = 'access_key' SECRET_KEY = 'secret_key' SESSION_TOKEN = 'session_token' kms_client = boto3 . client ( 'kms' , aws_access_key_id = ACCESS_KEY , aws_secret_access_key = SECRET_KEY , aws_session_token = SESSION_TOKEN ) key_id = 'key_id' address = get_eth_address ( key_id , kms_client ) signed_tx = sign_transaction ( tx_obj , key_id , kms_client )","title":"Authentication"},{"location":"usage/#get-ethereum-address-from-kms-key","text":"1 2 3 from ethereum_kms_signer import get_eth_address address = get_eth_address ( 'THE-AWS-KMS-ID' ) print ( address )","title":"Get ethereum address from KMS key"},{"location":"usage/#sign-a-transaction-object-with-kms-key","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from ethereum_kms_signer import sign_transaction dai_txn = dai . functions . transfer ( web3 . toChecksumAddress ( to_address . lower ()), amount ) . buildTransaction ( { \"nonce\" : nonce , } ) # Signing the transaction with KMS key signed_tx = sign_transaction ( dai_txn , key_id ) # send transaction tx_hash = web3 . eth . sendRawTransaction ( signed_tx . rawTransaction )","title":"Sign a transaction object with KMS key"},{"location":"usage/#provisioning-aws-kms-key-with-terraform","text":"An ECC_SECG_P256K1 key can be provisioned using terraform by using the following configuration along with the aws provider. More details can be found on provider docs 1 2 3 4 5 6 7 8 9 10 resource \"aws_kms_key\" \"my_very_secret_eth_account\" { description = \"ETH account #1\" key_usage = \"SIGN_VERIFY\" customer_master_key_spec = \"ECC_SECG_P256K1\" } resource \"aws_kms_alias\" \"my_very_secret_eth_account\" { name = \"eth-account-1\" target_key_id = aws_kms_key.my_very_secret_eth_account.id }","title":"Provisioning AWS KMS key with terraform"}]}